# ADR-0001: Introduce routing-key based event dispatching

## Status

Accepted – 2025-06-14

## Context

The first iteration of the Event Bus resolved handlers only by the **event class name**. This design was simple but soon proved to be too coarse-grained:

- Many events share the same class but carry different **metadata** that require different handling strategies (multi-tenant support, versioning, feature flags, etc.).
- Future integrations (e.g. RabbitMQ, Kafka, SNS/SQS) also rely on the concept of **routing keys**/topics. Mimicking that semantics inside the in-memory bus simplifies migrations.

Therefore we need a way to dispatch an incoming event to handlers that are selected by both

1. the event class, **and**
2. an arbitrary metadata object accompanying the event.

## Decision

1. **Handler selection key = Event + Routing Metadata**  
   A handler is uniquely identified not only by the event class but also by an optional `routingMetadata` object. This pair is wrapped into the `IEventHandlerSignature` structure when a handler is registered and into `IHandlerRetrievalOptions` when it is resolved.

2. **Hash-based storage**  
   Instead of concatenating the two components into a string, both `handlers` and `scopedHandlers` are stored in an `ObjectHashMap<IHandlerKey, …>` where `IHandlerKey = { event: string; routingMetadata: unknown }`. The map implementation performs a stable hash on the composite key, guaranteeing fast look-ups while supporting complex metadata objects.

3. **Registration API changes**

   - `addHandler` and `addScopedHandler` now take an `IEventHandlerSignature` (event + routingMetadata) rather than a plain string.
   - The register automatically keeps a catalog of all provided signatures for introspection.

4. **Retrieval API changes**

   - `get` now accepts `IHandlerRetrievalOptions` which bundles the event instance, optional `routingMetadata` and a per-call `context`.
   - `IHandlerCallOptions` remains unchanged – routing metadata is supplied directly in the retrieval options, not through the Event Bus.

5. **Event Bus**  
   The bus passes `{ event, context }` to the register. When richer routing rules are required, it will extend the options with `routingMetadata` and rely on the composite key automatically.

## Consequences

- Plain class-name routing still works: if `routingMetadata` is omitted the composite key collapses to just the event name. Existing code continues to function.
- At the same time, we can now express refined routing scenarios (multi-tenant, versioning, partitioning, etc.) without creating additional event subclasses.
- The hash-based key keeps the register agnostic of any string-encoding rules and avoids potential serialization issues.
- Upstream integrations with message brokers benefit from the richer routing semantics.

## Alternatives considered

- Building the routing key inside the handler register – rejected to keep the register completely agnostic of domain concepts and allow callers to customise the key freely.

## Follow-ups

- Extend documentation and examples to demonstrate multi-tenant handler registration.
